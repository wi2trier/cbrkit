from collections.abc import Callable, Collection
from dataclasses import dataclass
from typing import override

from ..typing import Casebase, IndexableFunc, MapAdaptationFunc

type KeyFunc[K, V] = Callable[[Casebase[K, V]], K]

__all__ = [
    "KeyFunc",
    "auto_key",
    "indexable",
    "static",
]


@dataclass(slots=True, frozen=True)
class auto_key[K, V](MapAdaptationFunc[K, V]):
    """Store a case using a key generated by a callable.

    Args:
        key_func: A callable that generates a new key given the current casebase.

    Examples:
        >>> func = auto_key(key_func=lambda cb: max(cb.keys(), default=-1) + 1)
        >>> result = func({0: "a", 1: "b"}, "c")
        >>> result[2]
        'c'
    """

    key_func: KeyFunc[K, V]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        new_key = self.key_func(casebase)
        updated = dict(casebase)
        updated[new_key] = query

        return updated


@dataclass(slots=True, frozen=True)
class static[K, V](MapAdaptationFunc[K, V]):
    """Storage function that generates keys from a fixed casebase.

    Generates a key via ``key_func`` using the provided ``casebase``
    instead of the pipeline casebase, avoiding key collisions with the
    full collection.
    Unlike ``indexable``, this does not maintain any internal state.

    Args:
        key_func: Callable that generates a new key given a casebase.
        casebase: The full casebase used for key generation.

    Examples:
        >>> func = static(
        ...     key_func=lambda cb: max(cb.keys(), default=-1) + 1,
        ...     casebase={0: "a", 1: "b", 2: "c"},
        ... )
        >>> result = func({1: "b"}, "d")
        >>> result == {1: "b", 3: "d"}
        True
    """

    key_func: KeyFunc[K, V]
    casebase: Casebase[K, V]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        new_key = self.key_func(self.casebase)
        return {**casebase, new_key: query}


@dataclass(slots=True, frozen=True)
class indexable[K, V](MapAdaptationFunc[K, V]):
    """Storage function that keeps an IndexableFunc's index in sync.

    Generates a key via ``key_func`` and inserts the case into the casebase,
    routing through the IndexableFunc's index when it is pre-populated.

    Behavior depends on whether the index is pre-populated:

    - **Empty index**: the key is generated from the pipeline casebase,
      and ``create_index`` rebuilds the index from the result.
    - **Pre-populated index**: the key is generated from the full index
      instead of the pipeline casebase.
      Only newly added keys are merged back into the pipeline casebase,
      and the index is updated incrementally via ``update_index``.

    The pre-populated path lets the retain phase store cases into a
    full collection while the pipeline only carries a filtered subset.

    Note:
        When combined with ``dropout``, the index is rebuilt before
        dropout filters cases.
        The index will be corrected on the next retain call.

    Args:
        key_func: Callable that generates a new key given a casebase.
        indexable_func: The indexable function whose index will be kept in sync.

    Examples:
        >>> from cbrkit.retain.storage import indexable
        >>> class Store:
        ...     def __init__(self):
        ...         self._data = {}
        ...     @property
        ...     def index(self):
        ...         return self._data
        ...     def create_index(self, data):
        ...         self._data = dict(data)
        ...     def update_index(self, data):
        ...         self._data.update(data)
        ...     def delete_index(self, data):
        ...         for k in data:
        ...             self._data.pop(k, None)
        >>> store = Store()
        >>> func = indexable(
        ...     key_func=lambda cb: max(cb.keys(), default=-1) + 1,
        ...     indexable_func=store,
        ... )
        >>> result = func({0: "a", 1: "b"}, "c")
        >>> result[2]
        'c'
        >>> store.index == result
        True

        Pre-populated index routes storage through the full collection:

        >>> store.create_index({0: "a", 1: "b", 2: "c"})
        >>> result = func({1: "b"}, "d")
        >>> result == {1: "b", 3: "d"}
        True
        >>> store.index == {0: "a", 1: "b", 2: "c", 3: "d"}
        True
    """

    key_func: KeyFunc[K, V]
    indexable_func: IndexableFunc[Casebase[K, V], Collection[K]]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        current_index = self.indexable_func.index

        if current_index:
            new_key = self.key_func(current_index)
            new_entry: Casebase[K, V] = {new_key: query}
            self.indexable_func.update_index(new_entry)
            return {**casebase, **new_entry}

        new_key = self.key_func(casebase)
        updated: Casebase[K, V] = {**casebase, new_key: query}
        self.indexable_func.create_index(updated)
        return updated
