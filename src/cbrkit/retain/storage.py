from collections.abc import Callable
from dataclasses import dataclass
from typing import Any, override

from ..typing import Casebase, IndexableFunc, MapAdaptationFunc

type KeyFunc[K, V] = Callable[[Casebase[K, V]], K]

__all__ = [
    "KeyFunc",
    "auto_key",
    "indexable",
    "static",
]


@dataclass(slots=True, frozen=True)
class auto_key[K, V](MapAdaptationFunc[K, V]):
    """Store cases using keys generated by a callable.

    Each value in the pipeline casebase is added with a new key
    generated by ``key_func``.

    Args:
        key_func: A callable that generates a new key given the current casebase.

    Examples:
        >>> func = auto_key(key_func=lambda cb: max(cb.keys(), default=-1) + 1)
        >>> result = func({0: "a", 1: "b"}, "c")
        >>> result == {0: "a", 1: "b", 2: "a", 3: "b"}
        True
    """

    key_func: KeyFunc[K, V]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        updated = dict(casebase)

        for value in casebase.values():
            new_key = self.key_func(updated)
            updated[new_key] = value

        return updated


@dataclass(slots=True, frozen=True)
class static[K, V](MapAdaptationFunc[K, V]):
    """Storage function that generates keys from a fixed casebase.

    Generates keys via ``key_func`` using the provided ``casebase``
    instead of the pipeline casebase, avoiding key collisions with the
    full collection.
    Each value in the pipeline casebase is added with a new key.
    Unlike ``indexable``, this does not maintain any internal state.

    Args:
        key_func: Callable that generates a new key given a casebase.
        casebase: The full casebase used for key generation.

    Examples:
        >>> func = static(
        ...     key_func=lambda cb: max(cb.keys(), default=-1) + 1,
        ...     casebase={0: "a", 1: "b", 2: "c"},
        ... )
        >>> result = func({1: "b"}, "d")
        >>> result == {0: "a", 1: "b", 2: "c", 3: "b"}
        True
    """

    key_func: KeyFunc[K, V]
    casebase: Casebase[K, V]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        combined = dict(self.casebase)

        for value in casebase.values():
            new_key = self.key_func(combined)
            combined[new_key] = value

        return combined


@dataclass(slots=True, frozen=True)
class indexable[K, V](MapAdaptationFunc[K, V]):
    """Storage function that keeps an IndexableFunc's index in sync.

    Adds the pipeline casebase values to the index with new keys
    generated via ``key_func``.

    Behavior depends on whether the index is pre-populated:

    - **Empty index**: ``create_index`` is called with the pipeline
      casebase and the casebase is returned as-is.
    - **Pre-populated index**: keys are generated from the full index
      instead of the pipeline casebase to avoid collisions.
      Only newly added keys are merged back into the pipeline casebase,
      and the index is updated incrementally via ``update_index``.

    The pre-populated path lets the retain phase store cases into a
    full collection while the pipeline only carries a filtered subset.

    Note:
        When combined with ``dropout``, the index is rebuilt before
        dropout filters cases.
        The index will be corrected on the next retain call.

    Args:
        key_func: Callable that generates a new key given a casebase.
        indexable_func: The indexable function whose index will be kept in sync.

    Examples:
        >>> from cbrkit.retain.storage import indexable
        >>> class Store:
        ...     def __init__(self):
        ...         self._data = {}
        ...     @property
        ...     def index(self):
        ...         return self._data
        ...     def create_index(self, data):
        ...         self._data = dict(data)
        ...     def update_index(self, data):
        ...         self._data.update(data)
        ...     def delete_index(self, data):
        ...         for k in data:
        ...             self._data.pop(k, None)
        >>> store = Store()
        >>> func = indexable(
        ...     key_func=lambda cb: max(cb.keys(), default=-1) + 1,
        ...     indexable_func=store,
        ... )
        >>> result = func({0: "a", 1: "b"}, "c")
        >>> result == {0: "a", 1: "b"}
        True
        >>> store.index == result
        True

        Pre-populated index routes storage through the full collection:

        >>> store.create_index({0: "a", 1: "b", 2: "c"})
        >>> result = func({1: "b"}, "d")
        >>> result == {0: "a", 1: "b", 2: "c", 3: "b"}
        True
        >>> store.index == result
        True
    """

    key_func: KeyFunc[K, V]
    indexable_func: IndexableFunc[Casebase[K, V], Any]

    @override
    def __call__(
        self,
        casebase: Casebase[K, V],
        query: V,
        /,
    ) -> Casebase[K, V]:
        current_index = self.indexable_func.index

        if current_index:
            combined = dict(current_index)

            for value in casebase.values():
                new_key = self.key_func(combined)
                combined[new_key] = value

            self.indexable_func.update_index(
                {k: v for k, v in combined.items() if k not in current_index}
            )
            return combined

        self.indexable_func.create_index(dict(casebase))
        return dict(casebase)
